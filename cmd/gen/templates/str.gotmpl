i.head++
i.tail = i.head

if i.head+1 < len(i.str) &&
	i.str[i.head] == '"' &&
	i.str[i.head+1] == '"' {
	i.head += 2
	i.tail = i.head
	goto BLOCK_STRING
}

// String value
if i.head < len(i.str) && i.str[i.head] == '"' {
	goto AFTER_STR_VAL
}
for {
	if i.head+15 < len(i.str) {
		// Fast path
		if lutStr[i.str[i.head]] == 1 {
			goto CHECK_STR_CHARACTER
		}
		if lutStr[i.str[i.head+1]] == 1 {
			i.head+=1
			goto CHECK_STR_CHARACTER
		}
		if lutStr[i.str[i.head+2]] == 1 {
			i.head+=2
			goto CHECK_STR_CHARACTER
		}
		if lutStr[i.str[i.head+3]] == 1 {
			i.head+=3
			goto CHECK_STR_CHARACTER
		}
		if lutStr[i.str[i.head+4]] == 1 {
			i.head+=4
			goto CHECK_STR_CHARACTER
		}
		if lutStr[i.str[i.head+5]] == 1 {
			i.head+=5
			goto CHECK_STR_CHARACTER
		}
		if lutStr[i.str[i.head+6]] == 1 {
			i.head+=6
			goto CHECK_STR_CHARACTER
		}
		if lutStr[i.str[i.head+7]] == 1 {
			i.head+=7
			goto CHECK_STR_CHARACTER
		}
		if lutStr[i.str[i.head+8]] == 1 {
			i.head+=8
			goto CHECK_STR_CHARACTER
		}
		if lutStr[i.str[i.head+9]] == 1 {
			i.head+=9
			goto CHECK_STR_CHARACTER
		}
		if lutStr[i.str[i.head+10]] == 1 {
			i.head+=10
			goto CHECK_STR_CHARACTER
		}
		if lutStr[i.str[i.head+11]] == 1 {
			i.head+=11
			goto CHECK_STR_CHARACTER
		}
		if lutStr[i.str[i.head+12]] == 1 {
			i.head+=12
			goto CHECK_STR_CHARACTER
		}
		if lutStr[i.str[i.head+13]] == 1 {
			i.head+=13
			goto CHECK_STR_CHARACTER
		}
		if lutStr[i.str[i.head+14]] == 1 {
			i.head+=14
			goto CHECK_STR_CHARACTER
		}
		if lutStr[i.str[i.head+15]] == 1 {
			i.head+=15
			goto CHECK_STR_CHARACTER
		}
		i.head += 16
	}
	if i.head >= len(i.str) {
		i.errc, i.expect = ErrUnexpEOF, ExpectEndOfString
		goto ERROR
	}
CHECK_STR_CHARACTER:
	switch i.str[i.head] {
	case '"':
		// i.head++
		goto AFTER_STR_VAL
	case '\\':
		i.head++
		if i.head >= len(i.str) {
			i.errc, i.expect = ErrUnexpEOF, ExpectEscapedSequence
			goto ERROR
		}
		switch i.str[i.head] {
		case '\\', '/', '"', 'b', 'f', 'r', 'n', 't':
			i.head++
		case 'u':
			if i.head+4 >= len(i.str) {
				switch {
				case i.head+1 < len(i.str) && lutHex[i.str[i.head+1]] != 2:
					i.head++
					i.errc, i.expect = ErrUnexpToken, ExpectEscapedUnicodeSequence
					goto ERROR
				case i.head+2 < len(i.str) &&lutHex[i.str[i.head+2]] != 2:
					i.head+=2
					i.errc, i.expect = ErrUnexpToken, ExpectEscapedUnicodeSequence
					goto ERROR
				case i.head+3 < len(i.str) &&lutHex[i.str[i.head+3]] != 2:
					i.head+=3
					i.errc, i.expect = ErrUnexpToken, ExpectEscapedUnicodeSequence
					goto ERROR
				case i.head+4 < len(i.str) && lutHex[i.str[i.head+4]] != 2:
					i.head+=4
					i.errc, i.expect = ErrUnexpToken, ExpectEscapedUnicodeSequence
					goto ERROR
				}
				i.head = len(i.str)
				i.errc, i.expect = ErrUnexpEOF, ExpectEscapedUnicodeSequence
				goto ERROR
			}
			if lutHex[i.str[i.head+4]] != 2 ||
				lutHex[i.str[i.head+3]] != 2 ||
				lutHex[i.str[i.head+2]] != 2 ||
				lutHex[i.str[i.head+1]] != 2 {
				switch {
				case lutHex[i.str[i.head+1]] != 2:
					i.head++
				case lutHex[i.str[i.head+2]] != 2:
					i.head+=2
				case lutHex[i.str[i.head+3]] != 2:
					i.head+=3
				case lutHex[i.str[i.head+4]] != 2:
					i.head+=4
				}
				i.errc, i.expect = ErrUnexpToken, ExpectEscapedUnicodeSequence
				goto ERROR
			}
			i.head+=4
		default:
			i.errc, i.expect = ErrUnexpToken, ExpectEscapedSequence
			goto ERROR
		}
		continue
	}
	if i.str[i.head] < 0x20 {
		i.errc, i.expect = ErrUnexpToken, ExpectEndOfString
		goto ERROR
	}
	i.head++
}

AFTER_STR_VAL:
// Callback for argument
i.token = TokenStr
{{- template "callback" . -}}
// Advance head index to include the closing double-quotes
i.head++
