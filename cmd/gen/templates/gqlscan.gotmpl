
package gqlscan

import (
	"fmt"
	"unicode/utf8"
	"strconv"
	"strings"
	"sync"
)

// Scan calls fn for every token it scans in str.
// If fn returns true then an error with code ErrCallbackFn is returned.
// If the returned error code == 0 then there was no error during the scan,
// this can also be checked using err.IsErr().
//
// WARNING: *Iterator passed to fn should never be aliased and
// used after Scan returns because it's returned to the pool
// and may be acquired by another call to Scan!
func Scan(str []byte, fn func(*Iterator) (err bool)) Error {
	{{ template "scan_body" dict "checkfn" true }}
}

// ScanAll calls fn for every token it scans in str.
// If the returned error code == 0 then there was no error during the scan,
// this can also be checked using err.IsErr().
//
// WARNING: *Iterator passed to fn should never be aliased and
// used after ScanAll returns because it's returned to the pool
// and may be acquired by another call to ScanAll!
func ScanAll(str []byte, fn func(*Iterator)) Error {
	{{ template "scan_body" dict "checkfn" false }}
}

// Iterator is a GraphQL iterator for lexical analysis.
//
// WARNING: An iterator instance shall never be aliased and/or used
// after Scan or ScanAll returns because it's returned to a global pool!
type Iterator struct {
	// stack holds either TokenArr or TokenObj
	// and is reset for every argument.
	stack []Token

	expect Expect
	token  Token

	// str holds the original source
	str []byte

	// tail and head represent the iterator tail and head indexes
	tail, head int
	levelSel   int

	// errc holds the recent error code
	errc ErrorCode
}

func (i *Iterator) stackReset() {
	i.stack = i.stack[:0]
}

func (i *Iterator) stackLen() int {
	return len(i.stack)
}

// stackPush pushes a new token onto the stack.
func (i *Iterator) stackPush(t Token) {
	i.stack = append(i.stack, t)
}

// stackPop pops the top element of the stack returning it.
// Returns 0 if the stack was empty.
func (i *Iterator) stackPop() {
	if l := len(i.stack); l > 0 {
		i.stack = i.stack[:l-1]
	}
}

// stackTop returns the last pushed token.
func (i *Iterator) stackTop() Token {
	if l := len(i.stack); l > 0 {
		return i.stack[l-1]
	}
	return 0
}

var iteratorPool = sync.Pool{
	New: func() interface{} {
		return &Iterator{
			stack: make([]Token, 64),
		}
	},
}

// LevelSelect returns the current selector level.
func (i *Iterator) LevelSelect() int {
	return i.levelSel
}

// IndexHead returns the current head index.
func (i *Iterator) IndexHead() int {
	return i.head
}

// IndexTail returns the current tail index.
// Returns -1 if the current token doesn't reflect a dynamic value.
func (i *Iterator) IndexTail() int {
	return i.tail
}

// Token returns the current token type.
func (i *Iterator) Token() Token {
	return i.token
}

// Value returns the raw value of the current token.
// For TokenStrBlock it's the raw uninterpreted body of the string,
// use ScanInterpreted for the interpreted value of the block string.
//
// WARNING: The returned byte slice refers to the same underlying memory
// as the byte slice passed to Scan and ScanAll as str parameter,
// copy it or use with caution!
func (i *Iterator) Value() []byte {
	if i.tail < 0 {
		return nil
	}
	return i.str[i.tail:i.head]
}

// ScanInterpreted calls fn writing the interpreted part of
// the value to buffer as long as fn doesn't return true and
// the scan didn't reach the end of the interpreted value.
func (i *Iterator) ScanInterpreted(
	buffer []byte,
	fn func(buffer []byte) (stop bool),
) {
	if len(buffer) < 1 {
		return
	}
	if i.token != TokenStrBlock {
		offset := 0
		for offset < len(i.Value()) {
			b := buffer
			v := i.Value()[offset:]
			if len(v) > len(b) {
				v = v[:len(b)]
			} else {
				b = b[:len(v)]
			}
			copy(b, v)
			if fn(b) {
				return
			}
			offset += len(v)
		}
		return
	}

	// Determine block prefix
	shortestPrefixLen := 0
	v := i.Value()
	start, end := 0, len(v)
	{
		lastLineBreak := 0
		for i := range v {
			if v[i] == '\n' {
				lastLineBreak = i
			}
			if v[i] != '\n' && v[i] != ' ' && v[i] != '\t' {
				start = lastLineBreak
				break
			}
		}
	FIND_END:
		for i := len(v) - 1; i >= 0; i-- {
			if v[i] == '\n' {
				for ; i >= 0; i-- {
					if v[i] != '\n' && v[i] != ' ' && v[i] != '\t' {
						end = i + 1
						break FIND_END
					}
				}
			}
		}
		v = v[start:end]
	COUNT_LOOP:
		for len(v) > 0 {
			if v[0] == '\n' {
				// Count prefix length
				l := 0
				for v = v[1:]; ; l++ {
					if l >= len(v) {
						break COUNT_LOOP
					} else if v[l] != ' ' && v[l] != '\t' {
						v = v[l:]
						if shortestPrefixLen == 0 || shortestPrefixLen > l {
							shortestPrefixLen = l
						}
						break
					}
				}
				continue
			}
			v = v[1:]
		}
	}

	{
		v, bi := i.Value()[start:end], 0

		write := func(b byte) (stop bool) {
			buffer[bi] = b
			bi++
			if bi >= len(buffer) {
				bi = 0
				return fn(buffer)
			}
			return false
		}

		for i := 0; i < len(v); {
			if v[i] == '\n' {
				if i != 0 {
					if write(v[i]) {
						return
					}
				}
				// Ignore prefix
				if i+shortestPrefixLen+1 <= len(v) {
					i += shortestPrefixLen + 1
				}
				if v[i] == '\n' {
					continue
				}
			}
			if v[i] == '\\' && i+3 <= len(v) &&
				v[i+3] == '"' &&
				v[i+2] == '"' &&
				v[i+1] == '"' {
				if write('"') {
					return
				}
				if write('"') {
					return
				}
				if write('"') {
					return
				}
				i += 4
				continue
			}
			if write(v[i]) {
				return
			}
			i++
		}
		if b := buffer[:bi]; len(b) > 0 {
			if fn(buffer[:bi]) {
				return
			}
		}
	}
}

// isHeadKeywordQuery returns true if the current head equals 'query'.
func (i *Iterator) isHeadKeywordQuery() bool {
	return i.head+4 < len(i.str) &&
		i.str[i.head+4] == 'y' &&
		i.str[i.head+3] == 'r' &&
		i.str[i.head+2] == 'e' &&
		i.str[i.head+1] == 'u' &&
		i.str[i.head] == 'q'
}

// isHeadKeywordMutation returns true if the current head equals 'mutation'.
func (i *Iterator) isHeadKeywordMutation() bool {
	return i.head+7 < len(i.str) &&
		i.str[i.head+7] == 'n' &&
		i.str[i.head+6] == 'o' &&
		i.str[i.head+5] == 'i' &&
		i.str[i.head+4] == 't' &&
		i.str[i.head+3] == 'a' &&
		i.str[i.head+2] == 't' &&
		i.str[i.head+1] == 'u' &&
		i.str[i.head] == 'm'
}

// isHeadKeywordSubscription returns true if
// the current head equals 'subscription'.
func (i *Iterator) isHeadKeywordSubscription() bool {
	return i.head+11 < len(i.str) &&
		i.str[i.head+11] == 'n' &&
		i.str[i.head+10] == 'o' &&
		i.str[i.head+9] == 'i' &&
		i.str[i.head+8] == 't' &&
		i.str[i.head+7] == 'p' &&
		i.str[i.head+6] == 'i' &&
		i.str[i.head+5] == 'r' &&
		i.str[i.head+4] == 'c' &&
		i.str[i.head+3] == 's' &&
		i.str[i.head+2] == 'b' &&
		i.str[i.head+1] == 'u' &&
		i.str[i.head] == 's'
}

// isHeadKeywordFragment returns true if the current head equals 'fragment'.
func (i *Iterator) isHeadKeywordFragment() bool {
	return i.head+7 < len(i.str) &&
		i.str[i.head+7] == 't' &&
		i.str[i.head+6] == 'n' &&
		i.str[i.head+5] == 'e' &&
		i.str[i.head+4] == 'm' &&
		i.str[i.head+3] == 'g' &&
		i.str[i.head+2] == 'a' &&
		i.str[i.head+1] == 'r' &&
		i.str[i.head] == 'f'
}

// Expect defines an expectation
type Expect int

// Expectations
const (
	_ Expect = iota
	ExpectVal
	ExpectValEnum
	ExpectDefaultVarVal
	ExpectDef
	ExpectOprName
	ExpectSelSet
	ExpectArgName
	ExpectEscapedSequence
	ExpectEscapedUnicodeSequence
	ExpectEndOfString
	ExpectEndOfBlockString
	ExpectColumnAfterArg
	ExpectFieldNameOrAlias
	ExpectFieldName
	ExpectSel
	ExpectDir
	ExpectDirName
	ExpectVar
	ExpectVarName
	ExpectVarRefName
	ExpectVarType
	ExpectColumnAfterVar
	ExpectObjFieldName
	ExpectColObjFieldName
	ExpectFragTypeCond
	ExpectFragKeywordOn
	ExpectFragName
	ExpectFrag
	ExpectSpreadName
	ExpectFragInlined
	ExpectAfterFieldName
	ExpectAfterSelection
	ExpectAfterValueInner
	ExpectAfterValueOuter
	ExpectAfterArgList
	ExpectAfterDefKeyword
	ExpectAfterVarType
	ExpectAfterVarTypeName
)

func (e Expect) String() string {
	switch e {
	case ExpectDef:
		return "definition"
	case ExpectOprName:
		return "operation name"
	case ExpectVal:
		return "value"
	case ExpectValEnum:
		return "enum value"
	case ExpectDefaultVarVal:
		return "default variable value"
	case ExpectSelSet:
		return "selection set"
	case ExpectArgName:
		return "argument name"
	case ExpectEscapedSequence:
		return "escaped sequence"
	case ExpectEscapedUnicodeSequence:
		return "escaped unicode sequence"
	case ExpectEndOfString:
		return "end of string"
	case ExpectEndOfBlockString:
		return "end of block string"
	case ExpectColumnAfterArg:
		return "column after argument name"
	case ExpectFieldNameOrAlias:
		return "field name or alias"
	case ExpectFieldName:
		return "field name"
	case ExpectSel:
		return "selection"
	case ExpectDir:
		return "directive name"
	case ExpectDirName:
		return "directive name"
	case ExpectVar:
		return "variable"
	case ExpectVarName:
		return "variable name"
	case ExpectVarRefName:
		return "referenced variable name"
	case ExpectVarType:
		return "variable type"
	case ExpectColumnAfterVar:
		return "column after variable name"
	case ExpectObjFieldName:
		return "object field name"
	case ExpectColObjFieldName:
		return "column after object field name"
	case ExpectFragTypeCond:
		return "fragment type condition"
	case ExpectFragKeywordOn:
		return "keyword 'on'"
	case ExpectFragName:
		return "fragment name"
	case ExpectFrag:
		return "fragment"
	case ExpectSpreadName:
		return "spread name"
	case ExpectFragInlined:
		return "inlined fragment"
	case ExpectAfterFieldName:
		return "selection, selection set or end of selection set"
	case ExpectAfterSelection:
		return "selection or end of selection set"
	case ExpectAfterValueInner:
		return "argument list closure or argument"
	case ExpectAfterValueOuter:
		return "argument list closure or argument"
	case ExpectAfterArgList:
		return "selection set or selection"
	case ExpectAfterDefKeyword:
		return "variable list or selection set"
	case ExpectAfterVarType:
		return "variable list closure or variable"
	case ExpectAfterVarTypeName:
		return "variable list closure or variable"
	}
	return ""
}

// Token defines the type of a token.
type Token int

// Token types
const (
	_ Token = iota
	TokenDefQry
	TokenDefMut
	TokenDefSub
	TokenDefFrag
	TokenOprName
	TokenDirName
	TokenVarList
	TokenVarListEnd
	TokenArgList
	TokenArgListEnd
	TokenSet
	TokenSetEnd
	TokenFragTypeCond
	TokenFragName
	TokenFragInline
	TokenNamedSpread
	TokenFieldAlias
	TokenField
	TokenArgName
	TokenEnumVal
	TokenArr
	TokenArrEnd
	TokenStr
	TokenStrBlock
	TokenInt
	TokenFloat
	TokenTrue
	TokenFalse
	TokenNull
	TokenVarName
	TokenVarTypeName
	TokenVarTypeArr
	TokenVarTypeArrEnd
	TokenVarTypeNotNull
	TokenVarRef
	TokenObj
	TokenObjEnd
	TokenObjField
)

func (t Token) String() string {
	switch t {
	case TokenDefQry:
		return "query definition"
	case TokenDefMut:
		return "mutation definition"
	case TokenDefSub:
		return "subscription definition"
	case TokenDefFrag:
		return "fragment definition"
	case TokenOprName:
		return "operation name"
	case TokenDirName:
		return "directive name"
	case TokenVarList:
		return "variable list"
	case TokenVarListEnd:
		return "variable list end"
	case TokenArgList:
		return "argument list"
	case TokenArgListEnd:
		return "argument list end"
	case TokenSet:
		return "selection set"
	case TokenSetEnd:
		return "selection set end"
	case TokenFragTypeCond:
		return "fragment type condition"
	case TokenFragName:
		return "fragment name"
	case TokenFragInline:
		return "fragment inline"
	case TokenNamedSpread:
		return "named spread"
	case TokenFieldAlias:
		return "field alias"
	case TokenField:
		return "field"
	case TokenArgName:
		return "argument name"
	case TokenEnumVal:
		return "enum value"
	case TokenArr:
		return "array"
	case TokenArrEnd:
		return "array end"
	case TokenStr:
		return "string"
	case TokenStrBlock:
		return "block string"
	case TokenInt:
		return "integer"
	case TokenFloat:
		return "float"
	case TokenTrue:
		return "true"
	case TokenFalse:
		return "false"
	case TokenNull:
		return "null"
	case TokenVarName:
		return "variable name"
	case TokenVarTypeName:
		return "variable type name"
	case TokenVarTypeArr:
		return "variable array type"
	case TokenVarTypeArrEnd:
		return "variable array type end"
	case TokenVarTypeNotNull:
		return "variable type not null"
	case TokenVarRef:
		return "variable reference"
	case TokenObj:
		return "object"
	case TokenObjEnd:
		return "object end"
	case TokenObjField:
		return "object field"
	}
	return ""
}

// ErrorCode defines the type of an error.
type ErrorCode int

const (
	_ ErrorCode = iota
	ErrCallbackFn
	ErrUnexpToken
	ErrUnexpEOF
	ErrIllegalFragName
	ErrInvalNum
	ErrInvalType
)

// Error is a GraphQL lexical scan error.
type Error struct {
	Index       int
	AtIndex     rune
	Code        ErrorCode
	Expectation Expect
}

// IsErr returns true if there is an error, otherwise returns false.
func (e Error) IsErr() bool {
	return e.Code != 0
}

func (e Error) Error() string {
	if e.Code == 0 {
		return ""
	}
	var b strings.Builder
	b.WriteString("error at index ")
	b.WriteString(strconv.Itoa(e.Index))
	if e.Code != ErrUnexpEOF {
		if e.AtIndex < 0x20 {
			b.WriteString(" (")
			b.WriteString(fmt.Sprintf("0x%x", e.AtIndex))
			b.WriteString(")")
		} else {
			b.WriteString(" ('")
			b.WriteRune(e.AtIndex)
			b.WriteString("')")
		}
	}
	switch e.Code {
	case ErrCallbackFn:
		b.WriteString(": callback function returned error")
	case ErrUnexpToken:
		b.WriteString(": unexpected token")
	case ErrIllegalFragName:
		b.WriteString(": illegal fragment name")
	case ErrInvalNum:
		b.WriteString(": invalid number value")
	case ErrInvalType:
		b.WriteString(": invalid type")
	case ErrUnexpEOF:
		b.WriteString(": unexpected end of file")
	}
	if e.Expectation != 0 {
		b.WriteString("; expected ")
		b.WriteString(e.Expectation.String())
	}
	return b.String()
}

type dirTarget int

const (
	_ dirTarget = iota
	dirOpr
	dirVar
	dirField
	dirFragRef
	dirFragInlineOrDef
)

// lutStr maps 0 to all bytes that don't require checking during string traversal.
// 1 is mapped to control, quotation mark (") and reverse solidus ("\").
// All other characters are mapped to 0.
var lutStr = [256]byte{
	0x00: 1, 0x01: 1, 0x02: 1, 0x03: 1, 0x04: 1, 0x05: 1, 0x06: 1, 0x07: 1,
	0x08: 1, 0x0b: 1, 0x0c: 1, 0x0e: 1, 0x0f: 1, 0x10: 1, 0x11: 1, 0x12: 1,
	0x13: 1, 0x14: 1, 0x15: 1, 0x16: 1, 0x17: 1, 0x18: 1, 0x19: 1, 0x1a: 1,
	0x1b: 1, 0x1c: 1, 0x1d: 1, 0x1e: 1, 0x1f: 1,

	'\\': 1, '"': 1,
}

// lutHex maps valid hex digits to 2. All other characters are mapped to 0.
var lutHex = [256]byte{
	'0': 2, '1': 2, '2': 2, '3': 2, '4': 2, '5': 2, '6': 2, '7': 2, '8': 2, '9': 2,
	'a': 2, 'b': 2, 'c': 2, 'd': 2, 'e': 2, 'f': 2,
	'A': 2, 'B': 2, 'C': 2, 'D': 2, 'E': 2, 'F': 2,
}

// lutIrrel maps irrelevant characters such as comma, whitespace,
// line-break, tab and carriage-return to 1.
// All other characters are mapped to 0.
var lutIrrel = [256]byte{
	',': 1, ' ': 1, '\n': 1, '\t': 1, '\r': 1,
}

// lutEndVal maps characters that can appear at the 
// end of a value to 1. All other characters are mapped to 0.
var lutEndVal = [256]byte{
	' ': 1, '\t': 1, '\r': 1, '\n': 1,
	',': 1, ')': 1, '}': 1, '{': 1, ']': 1, '[': 1, '#': 1,
}

// lutEndNum maps characters that can appear at the 
// end of a number value to 1. All other characters are mapped to 0.
var lutEndNum = [256]byte{
	' ': 1, '\t': 1, '\r': 1, '\n': 1, ',': 1, ')': 1, '}': 1, ']': 1, '#': 1,
}


// lutName maps:
//  characters names can start with to 1,
//  characters names can contain to <3,
//  digit characters to 2.
//  characters names can end at to 3,
//  illegal control characters to 5,
//  all other characters to 4.
var lutName = [256]byte{
	'_': 1,
	
	'A': 1, 'B': 1, 'C': 1, 'D': 1, 'E': 1, 'F': 1, 'G': 1,
	'H': 1, 'I': 1, 'J': 1, 'K': 1,	'L': 1, 'M': 1, 'N': 1,
	'O': 1, 'P': 1, 'Q': 1, 'R': 1, 'S': 1, 'T': 1, 'U': 1,
	'V': 1, 'W': 1, 'X': 1,	'Y': 1, 'Z': 1,
	
	'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1, 'g': 1,
	'h': 1, 'i': 1, 'j': 1, 'k': 1,	'l': 1, 'm': 1, 'n': 1,
	'o': 1, 'p': 1, 'q': 1, 'r': 1, 's': 1, 't': 1, 'u': 1,
	'v': 1, 'w': 1, 'x': 1,	'y': 1, 'z': 1,
	
	'0': 2, '1': 2, '2': 2, '3': 2, '4': 2, '5': 2, 
	'6': 2, '7': 2, '8': 2, '9': 2, 
	
	',': 3, ' ': 3, '\n': 3, '\t': 3, '\r': 3,
	
	0x21: 4, 0x22: 4, 0x23: 4, 0x24: 4, 0x25: 4, 0x26: 4, 0x27: 4, 0x28: 4,
	0x29: 4, 0x2a: 4, 0x2b: 4, 0x2d: 4, 0x2e: 4, 0x2f: 4, 0x3a: 4, 0x3b: 4,
	0x3c: 4, 0x3d: 4, 0x3e: 4, 0x3f: 4, 0x40: 4, 0x5b: 4, 0x5c: 4, 0x5d: 4,
	0x5e: 4, 0x60: 4, 0x7b: 4, 0x7c: 4, 0x7d: 4, 0x7e: 4, 0x7f: 4, 0x80: 4,
	0x81: 4, 0x82: 4, 0x83: 4, 0x84: 4, 0x85: 4, 0x86: 4, 0x87: 4, 0x88: 4,
	0x89: 4, 0x8a: 4, 0x8b: 4, 0x8c: 4, 0x8d: 4, 0x8e: 4, 0x8f: 4, 0x90: 4,
	0x91: 4, 0x92: 4, 0x93: 4, 0x94: 4, 0x95: 4, 0x96: 4, 0x97: 4, 0x98: 4,
	0x99: 4, 0x9a: 4, 0x9b: 4, 0x9c: 4, 0x9d: 4, 0x9e: 4, 0x9f: 4, 0xa0: 4,
	0xa1: 4, 0xa2: 4, 0xa3: 4, 0xa4: 4, 0xa5: 4, 0xa6: 4, 0xa7: 4, 0xa8: 4,
	0xa9: 4, 0xaa: 4, 0xab: 4, 0xac: 4, 0xad: 4, 0xae: 4, 0xaf: 4, 0xb0: 4,
	0xb1: 4, 0xb2: 4, 0xb3: 4, 0xb4: 4, 0xb5: 4, 0xb6: 4, 0xb7: 4, 0xb8: 4,
	0xb9: 4, 0xba: 4, 0xbb: 4, 0xbc: 4, 0xbd: 4, 0xbe: 4, 0xbf: 4, 0xc0: 4,
	0xc1: 4, 0xc2: 4, 0xc3: 4, 0xc4: 4, 0xc5: 4, 0xc6: 4, 0xc7: 4, 0xc8: 4,
	0xc9: 4, 0xca: 4, 0xcb: 4, 0xcc: 4, 0xcd: 4, 0xce: 4, 0xcf: 4, 0xd0: 4,
	0xd1: 4, 0xd2: 4, 0xd3: 4, 0xd4: 4, 0xd5: 4, 0xd6: 4, 0xd7: 4, 0xd8: 4,
	0xd9: 4, 0xda: 4, 0xdb: 4, 0xdc: 4, 0xdd: 4, 0xde: 4, 0xdf: 4, 0xe0: 4,
	0xe1: 4, 0xe2: 4, 0xe3: 4, 0xe4: 4, 0xe5: 4, 0xe6: 4, 0xe7: 4, 0xe8: 4,
	0xe9: 4, 0xea: 4, 0xeb: 4, 0xec: 4, 0xed: 4, 0xee: 4, 0xef: 4, 0xf0: 4,
	0xf1: 4, 0xf2: 4, 0xf3: 4, 0xf4: 4, 0xf5: 4, 0xf6: 4, 0xf7: 4, 0xf8: 4,
	0xf9: 4, 0xfa: 4, 0xfb: 4, 0xfc: 4, 0xfd: 4, 0xfe: 4, 0xff: 4,

	0x00: 5, 0x01: 5, 0x02: 5, 0x03: 5, 0x04: 5, 0x05: 5, 0x06: 5, 0x07: 5,
	0x08: 5, 0x0b: 5, 0x0c: 5, 0x0e: 5, 0x0f: 5, 0x10: 5, 0x11: 5, 0x12: 5,
	0x13: 5, 0x14: 5, 0x15: 5, 0x16: 5, 0x17: 5, 0x18: 5, 0x19: 5, 0x1a: 5,
	0x1b: 5, 0x1c: 5, 0x1d: 5, 0x1e: 5, 0x1f: 5,
}
